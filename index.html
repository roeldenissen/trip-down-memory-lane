<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Trip Down Memory Lane</title>

  <style>
    /* ============ FONTS (offline) ============ */
    @font-face {
      font-family: 'Playfair Display';
      font-style: normal;
      font-weight: 400;
      font-display: swap;
      src: url(assets/fonts/playfair-display-latin.woff2) format('woff2');
    }
    @font-face {
      font-family: 'Playfair Display';
      font-style: normal;
      font-weight: 600;
      font-display: swap;
      src: url(assets/fonts/playfair-display-latin.woff2) format('woff2');
    }
    @font-face {
      font-family: 'Playfair Display';
      font-style: normal;
      font-weight: 700;
      font-display: swap;
      src: url(assets/fonts/playfair-display-latin.woff2) format('woff2');
    }
    @font-face {
      font-family: 'Lato';
      font-style: normal;
      font-weight: 300;
      font-display: swap;
      src: url(assets/fonts/lato-300-latin.woff2) format('woff2');
    }
    @font-face {
      font-family: 'Lato';
      font-style: normal;
      font-weight: 400;
      font-display: swap;
      src: url(assets/fonts/lato-400-latin.woff2) format('woff2');
    }
    @font-face {
      font-family: 'Lato';
      font-style: normal;
      font-weight: 700;
      font-display: swap;
      src: url(assets/fonts/lato-700-latin.woff2) format('woff2');
    }

    /* ============ RESET & BASE ============ */
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    :root {
      --gold: #C9A84C;
      --gold-light: #E8D5A3;
      --gold-dark: #A07D2E;
      --cream: #FDF8EE;
      --cream-dark: #F5ECDA;
      --brown: #5C4033;
      --text: #3A3028;
      --text-light: #6B5E50;
      --white: #FFFFFF;
      --success: #5A8F5A;
      --success-dark: #4A7F4A;
      --shadow: 0 4px 20px rgba(92, 64, 51, 0.12);
      --shadow-lg: 0 8px 40px rgba(92, 64, 51, 0.18);
      --radius: 16px;
      --radius-sm: 10px;
    }

    html, body {
      height: 100%;
      font-family: 'Lato', -apple-system, sans-serif;
      background: var(--cream);
      color: var(--text);
      overflow: hidden;
      -webkit-tap-highlight-color: transparent;
    }

    h1, h2, h3, h4 {
      font-family: 'Playfair Display', Georgia, serif;
    }

    /* ============ SCREENS ============ */
    .screen {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s ease;
    }

    .screen.active {
      opacity: 1;
      pointer-events: auto;
    }

    /* ============ START SCREEN ============ */
    #start-screen {
      background: linear-gradient(145deg, #FDF8EE 0%, #F5ECDA 50%, #E8D5A3 100%);
      justify-content: center;
      align-items: center;
      text-align: center;
      padding: 40px;
    }

    .start-ornament {
      font-size: 48px;
      color: var(--gold);
      margin-bottom: 10px;
      letter-spacing: 16px;
    }

    .start-title {
      font-size: 52px;
      font-weight: 700;
      color: var(--brown);
      line-height: 1.15;
      margin-bottom: 8px;
    }

    .start-subtitle {
      font-size: 26px;
      font-weight: 300;
      color: var(--text-light);
      margin-bottom: 6px;
    }

    .start-names {
      font-family: 'Playfair Display', Georgia, serif;
      font-size: 36px;
      font-weight: 600;
      color: var(--gold-dark);
      margin-bottom: 4px;
    }

    .start-years {
      font-size: 20px;
      color: var(--text-light);
      font-weight: 300;
      margin-bottom: 50px;
    }

    .start-years span {
      color: var(--gold);
      font-weight: 700;
      font-size: 24px;
    }

    /* ============ BUTTONS ============ */
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      padding: 18px 44px;
      border: none;
      border-radius: 50px;
      font-family: 'Lato', sans-serif;
      font-size: 20px;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.3s ease;
      text-decoration: none;
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--gold) 0%, var(--gold-dark) 100%);
      color: var(--white);
      box-shadow: 0 4px 20px rgba(201, 168, 76, 0.4);
    }

    .btn-primary:active {
      transform: scale(0.97);
      box-shadow: 0 6px 28px rgba(201, 168, 76, 0.5);
    }

    .btn-success {
      background: linear-gradient(135deg, var(--success) 0%, var(--success-dark) 100%);
      color: var(--white);
      box-shadow: 0 4px 20px rgba(90, 143, 90, 0.4);
    }

    .btn-success:active {
      transform: scale(0.97);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* ============ STOP LIST SCREEN ============ */
    #list-screen {
      flex-direction: column;
      background: #dde8cd;
    }

    .list-header {
      background: rgba(255, 255, 255, 0.92);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      padding: 14px 24px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      box-shadow: 0 2px 10px rgba(0,0,0,0.08);
      z-index: 10;
      flex-shrink: 0;
    }

    .list-header-title {
      font-size: 22px;
      font-weight: 600;
      color: var(--brown);
    }

    .list-progress {
      font-size: 15px;
      color: var(--text-light);
      text-align: right;
    }

    .list-progress span {
      color: var(--gold-dark);
      font-weight: 700;
    }

    /* Stop list - route container */
    .stop-list {
      flex: 1;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      padding: 20px 24px 60px;
      position: relative;
    }

    /* SVG route background */
    .route-svg-bg {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      pointer-events: none;
    }

    /* Nature decorations */
    .nature-deco {
      position: absolute;
      z-index: 1;
      pointer-events: none;
      opacity: 0.5;
      font-size: 20px;
    }

    /* Route items container for zigzag layout */
    .route-items {
      position: relative;
      z-index: 2;
      max-width: 800px;
      margin: 0 auto;
    }

    /* Stop card in zigzag layout */
    .stop-list-item {
      display: flex;
      align-items: center;
      gap: 14px;
      background: rgba(255, 255, 255, 0.93);
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      border-radius: var(--radius);
      padding: 16px 18px;
      width: 48%;
      max-width: 360px;
      box-shadow: 0 3px 16px rgba(92, 64, 51, 0.1);
      transition: all 0.3s;
      border-left: 4px solid transparent;
      position: relative;
      z-index: 2;
      /* Horizontal position set dynamically via margin-left in JS */
    }

    /* Connector spacing between items */
    .stop-list-connector {
      height: 60px;
      position: relative;
      z-index: 0;
    }

    /* Completed stop */
    .stop-list-item.completed {
      border-left-color: var(--success);
      cursor: pointer;
    }

    .stop-list-item.completed:active {
      transform: scale(0.98);
    }

    .stop-list-item.completed .stop-list-number {
      background: linear-gradient(135deg, var(--success) 0%, var(--success-dark) 100%);
    }

    /* Current stop */
    .stop-list-item.current {
      border-left-color: var(--gold);
      box-shadow: 0 4px 24px rgba(201, 168, 76, 0.3);
      background: rgba(255, 255, 255, 0.97);
    }

    .stop-list-item.current .stop-list-number {
      background: linear-gradient(135deg, var(--gold) 0%, var(--gold-dark) 100%);
      animation: pulse-number 2s ease-in-out infinite;
    }

    @keyframes pulse-number {
      0%, 100% { box-shadow: 0 0 0 0 rgba(201, 168, 76, 0); }
      50% { box-shadow: 0 0 0 6px rgba(201, 168, 76, 0.2); }
    }

    /* Locked stop */
    .stop-list-item.locked {
      pointer-events: none;
      user-select: none;
      -webkit-user-select: none;
      background: rgba(255, 255, 255, 0.45);
      box-shadow: 0 2px 8px rgba(92, 64, 51, 0.05);
    }

    .stop-list-item.locked .stop-list-info {
      filter: blur(5px);
    }

    .stop-list-item.locked .stop-list-number {
      background: #bbb;
    }

    .stop-list-item.locked .stop-list-action {
      filter: blur(5px);
    }

    .stop-list-number {
      width: 42px;
      height: 42px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 17px;
      color: var(--white);
      flex-shrink: 0;
      background: #bbb;
    }

    .stop-list-info {
      flex: 1;
      transition: filter 0.3s;
      min-width: 0;
    }

    .stop-list-title {
      font-family: 'Playfair Display', Georgia, serif;
      font-size: 16px;
      font-weight: 600;
      color: var(--brown);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .stop-list-address {
      font-size: 12px;
      color: var(--text-light);
      margin-top: 2px;
      display: flex;
      align-items: center;
      gap: 4px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .stop-list-address::before {
      content: "\1F4CD";
      font-size: 11px;
      flex-shrink: 0;
    }

    .stop-list-action {
      flex-shrink: 0;
      transition: filter 0.3s;
    }

    .stop-list-check {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .stop-list-check-icon {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: var(--success);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: 700;
      flex-shrink: 0;
    }

    .stop-list-score {
      font-size: 12px;
      font-weight: 700;
      color: var(--success);
      white-space: nowrap;
    }

    .btn-arrive {
      padding: 10px 20px;
      font-size: 14px;
      border-radius: 50px;
      border: none;
      background: linear-gradient(135deg, var(--gold) 0%, var(--gold-dark) 100%);
      color: white;
      font-family: 'Lato', sans-serif;
      font-weight: 700;
      cursor: pointer;
      box-shadow: 0 3px 12px rgba(201, 168, 76, 0.35);
      transition: all 0.2s;
      white-space: nowrap;
    }

    .btn-arrive:active {
      transform: scale(0.95);
    }

    .stop-list-lock {
      font-size: 20px;
      opacity: 0.3;
    }

    /* Start & finish markers */
    .route-marker {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 0;
      position: relative;
      z-index: 2;
      justify-content: center;
    }

    .route-marker-icon {
      font-size: 24px;
    }

    .route-marker-text {
      font-family: 'Playfair Display', Georgia, serif;
      font-size: 15px;
      font-weight: 600;
      color: var(--text-light);
      font-style: italic;
    }

    .route-marker.start { padding-bottom: 4px; }
    .route-marker.finish { padding-top: 4px; }

    /* Last stop = finish styling */
    .stop-list-item.is-finish {
      border-left-color: var(--gold) !important;
      background: linear-gradient(135deg, rgba(255,255,255,0.97) 0%, rgba(253,248,238,0.97) 100%);
      box-shadow: 0 4px 24px rgba(201, 168, 76, 0.25);
    }
    .stop-list-item.is-finish .stop-list-number {
      background: linear-gradient(135deg, var(--gold) 0%, var(--gold-dark) 100%);
      font-size: 14px;
    }
    .stop-list-item.is-finish.completed {
      border-left-color: var(--success) !important;
      background: linear-gradient(135deg, rgba(255,255,255,0.97) 0%, rgba(240,248,240,0.97) 100%);
    }
    .stop-list-item.is-finish.completed .stop-list-number {
      background: linear-gradient(135deg, var(--success) 0%, var(--success-dark) 100%);
    }
    .finish-badge {
      font-size: 11px;
      font-weight: 700;
      color: var(--gold-dark);
      text-transform: uppercase;
      letter-spacing: 1px;
      display: flex;
      align-items: center;
      gap: 4px;
      margin-top: 2px;
    }
    .finish-badge-icon { font-size: 13px; }

    /* ============ STOP SCREEN ============ */
    #stop-screen {
      background: var(--cream);
      flex-direction: column;
    }

    .stop-header {
      background: var(--white);
      padding: 14px 24px;
      display: flex;
      align-items: center;
      gap: 16px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.08);
      z-index: 10;
      flex-shrink: 0;
    }

    .back-btn {
      background: none;
      border: 2px solid var(--gold-light);
      border-radius: 50%;
      width: 44px;
      height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: var(--brown);
      font-size: 20px;
      flex-shrink: 0;
      transition: all 0.2s;
    }

    .back-btn:active {
      background: var(--cream);
    }

    .stop-header-info { flex: 1; }

    .stop-header-number {
      font-size: 13px;
      color: var(--gold-dark);
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .stop-header-title {
      font-size: 22px;
      font-weight: 600;
      color: var(--brown);
    }

    .stop-content {
      flex: 1;
      overflow-y: auto;
      padding: 24px;
      -webkit-overflow-scrolling: touch;
    }

    .stop-description {
      font-size: 17px;
      color: var(--text-light);
      line-height: 1.6;
      margin-bottom: 24px;
      font-style: italic;
    }

    /* Video */
    .video-section { margin-bottom: 32px; }

    .section-label {
      font-size: 14px;
      font-weight: 700;
      color: var(--gold-dark);
      text-transform: uppercase;
      letter-spacing: 1.5px;
      margin-bottom: 12px;
    }

    .video-container {
      position: relative;
      width: 100%;
      padding-bottom: 56.25%;
      border-radius: var(--radius);
      overflow: hidden;
      background: #1a1a1a;
      box-shadow: var(--shadow);
    }

    .video-container video {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      border: none;
    }

    .video-placeholder {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #888;
      font-size: 16px;
      gap: 8px;
    }

    .video-placeholder-icon { font-size: 48px; opacity: 0.5; }

    /* Questions */
    .questions-section { margin-bottom: 24px; }

    .question-card {
      background: var(--white);
      border-radius: var(--radius);
      padding: 24px;
      margin-bottom: 16px;
      box-shadow: var(--shadow);
      border-left: 4px solid var(--gold);
      transition: border-color 0.3s;
    }

    .question-card.error {
      border-left-color: #D9534F;
      animation: shake 0.4s ease;
    }

    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      20%, 60% { transform: translateX(-6px); }
      40%, 80% { transform: translateX(6px); }
    }

    .question-number {
      font-size: 12px;
      font-weight: 700;
      color: var(--gold);
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 6px;
    }

    .question-text {
      font-family: 'Playfair Display', Georgia, serif;
      font-size: 20px;
      font-weight: 600;
      color: var(--brown);
      line-height: 1.4;
      margin-bottom: 16px;
    }

    .answer-input {
      width: 100%;
      padding: 14px 18px;
      border: 2px solid var(--cream-dark);
      border-radius: var(--radius-sm);
      font-family: 'Lato', sans-serif;
      font-size: 17px;
      color: var(--text);
      background: var(--cream);
      resize: vertical;
      min-height: 60px;
      transition: border-color 0.2s;
    }

    .answer-input:focus {
      outline: none;
      border-color: var(--gold);
      background: var(--white);
    }

    .answer-input.error {
      border-color: #D9534F;
    }

    .answer-input.correct {
      border-color: var(--success);
      background: #f0f8f0;
    }

    .answer-input.wrong {
      border-color: #D9534F;
      background: #fdf0f0;
    }

    .answer-input:disabled {
      opacity: 0.7;
      cursor: not-allowed;
    }

    .answer-input::placeholder { color: #B8AFA3; }

    /* Answer feedback */
    .answer-feedback {
      margin-top: 12px;
      padding: 12px 16px;
      border-radius: var(--radius-sm);
      font-size: 15px;
      line-height: 1.5;
      display: none;
    }

    .answer-feedback.show { display: block; }

    .answer-feedback.correct {
      background: #e8f5e8;
      color: #2d6a2d;
      border: 1px solid #c3e6c3;
    }

    .answer-feedback.wrong {
      background: #fde8e8;
      color: #8b2d2d;
      border: 1px solid #f0c3c3;
    }

    .answer-feedback-icon {
      font-weight: 700;
      margin-right: 6px;
    }

    .answer-feedback .correct-answer {
      display: block;
      margin-top: 6px;
      font-weight: 700;
    }

    .answer-feedback .hint-text {
      display: block;
      margin-top: 4px;
      font-style: italic;
      opacity: 0.85;
    }

    .question-card.correct {
      border-left-color: var(--success);
    }

    .question-card.wrong {
      border-left-color: #D9534F;
    }

    /* Submit section */
    .submit-section {
      text-align: center;
      padding: 12px 0 40px;
    }

    .submit-hint {
      font-size: 14px;
      color: var(--text-light);
      margin-top: 10px;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .submit-hint.show { opacity: 1; }

    /* Score display in success overlay */
    .success-score {
      font-size: 48px;
      font-weight: 700;
      color: var(--gold-dark);
      font-family: 'Playfair Display', Georgia, serif;
      margin-bottom: 8px;
    }

    /* ============ SUCCESS OVERLAY ============ */
    .success-overlay {
      position: fixed;
      inset: 0;
      background: rgba(92, 64, 51, 0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.4s ease;
    }

    .success-overlay.show {
      opacity: 1;
      pointer-events: auto;
    }

    .success-card {
      background: white;
      border-radius: 24px;
      padding: 48px 40px;
      text-align: center;
      max-width: 420px;
      margin: 20px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      transform: scale(0.8);
      transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    .success-overlay.show .success-card {
      transform: scale(1);
    }

    .success-icon {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--success) 0%, var(--success-dark) 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto 20px;
      font-size: 40px;
      color: white;
    }

    /* ============ CONFETTI ============ */
    .confetti-container {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 200;
      overflow: hidden;
    }
    .confetti-piece {
      position: absolute;
      width: 10px;
      height: 10px;
      top: -10px;
      opacity: 0;
      animation: confetti-fall linear forwards;
    }
    @keyframes confetti-fall {
      0% { opacity: 1; transform: translateY(0) rotateZ(0deg) rotateX(0deg) translateX(0); }
      25% { opacity: 1; transform: translateY(25vh) rotateZ(180deg) rotateX(90deg) translateX(var(--sway)); }
      50% { opacity: 1; transform: translateY(50vh) rotateZ(360deg) rotateX(180deg) translateX(calc(var(--sway) * -0.5)); }
      75% { opacity: 1; transform: translateY(75vh) rotateZ(540deg) rotateX(270deg) translateX(var(--sway)); }
      100% { opacity: 0; transform: translateY(105vh) rotateZ(720deg) rotateX(360deg) translateX(0); }
    }

    .success-title {
      font-family: 'Playfair Display', Georgia, serif;
      font-size: 28px;
      font-weight: 700;
      color: var(--brown);
      margin-bottom: 8px;
    }

    .success-text {
      font-size: 17px;
      color: var(--text-light);
      line-height: 1.5;
      margin-bottom: 28px;
    }

    /* ============ FINISH SCREEN ============ */
    #finish-screen {
      background: linear-gradient(145deg, #FDF8EE 0%, #F5ECDA 50%, #E8D5A3 100%);
      justify-content: center;
      align-items: center;
      text-align: center;
      padding: 40px;
    }

    .finish-icon {
      font-size: 80px;
      margin-bottom: 16px;
    }

    .finish-title {
      font-size: 44px;
      font-weight: 700;
      color: var(--brown);
      line-height: 1.2;
      margin-bottom: 12px;
    }

    .finish-text {
      font-size: 20px;
      color: var(--text-light);
      font-weight: 300;
      line-height: 1.5;
      max-width: 500px;
      margin-bottom: 40px;
    }

    /* ============ RESPONSIVE ============ */
    @media (max-width: 768px) {
      .start-title { font-size: 36px; }
      .start-names { font-size: 28px; }
      .start-subtitle { font-size: 20px; }
      .stop-content { padding: 16px; }
      .finish-title { font-size: 32px; }
      /* On narrow screens, less zigzag and smaller spacing */
      .stop-list-item {
        width: 85% !important;
        max-width: none !important;
        margin-left: 7% !important;
      }
      .stop-list-connector {
        height: 30px;
      }
    }

    @media (min-width: 1024px) {
      .stop-content {
        max-width: 900px;
        margin: 0 auto;
        padding: 32px;
      }
      .route-items {
        max-width: 900px;
      }
      .stop-list-item {
        width: 42%;
        max-width: 380px;
      }
      .stop-list-connector {
        height: 70px;
      }
    }

    /* Scrollbar */
    .stop-content::-webkit-scrollbar,
    .stop-list::-webkit-scrollbar { width: 4px; }
    .stop-content::-webkit-scrollbar-track,
    .stop-list::-webkit-scrollbar-track { background: transparent; }
    .stop-content::-webkit-scrollbar-thumb,
    .stop-list::-webkit-scrollbar-thumb { background: rgba(201, 168, 76, 0.3); border-radius: 2px; }
  </style>
</head>
<body>

  <!-- ========== START SCREEN ========== -->
  <div id="start-screen" class="screen active">
    <div class="start-ornament">&#10045; &#10045; &#10045;</div>
    <h1 class="start-title">Trip Down<br>Memory Lane</h1>
    <p class="start-subtitle">Een fietstocht door de herinneringen</p>
    <p class="start-names" id="start-names"></p>
    <p class="start-years" id="start-years"></p>
    <button class="btn btn-primary" onclick="showStopList()">
      Start de tocht &#10148;
    </button>
  </div>

  <!-- ========== STOP LIST SCREEN ========== -->
  <div id="list-screen" class="screen">
    <div class="list-header">
      <h2 class="list-header-title">Trip Down Memory Lane</h2>
      <div class="list-progress">
        <span id="completed-count">0</span> / <span id="total-count">0</span> stops
        <div id="total-score" style="font-size: 13px; color: var(--success); font-weight: 700; margin-top: 2px;"></div>
      </div>
    </div>
    <div class="stop-list" id="stop-list-area">
      <!-- Filled dynamically -->
    </div>
  </div>

  <!-- ========== STOP SCREEN ========== -->
  <div id="stop-screen" class="screen">
    <div class="stop-header">
      <button class="back-btn" id="back-btn" onclick="showStopList()" style="display:none;">&#8592;</button>
      <div class="stop-header-info">
        <div class="stop-header-number" id="stop-number"></div>
        <h2 class="stop-header-title" id="stop-title"></h2>
      </div>
    </div>
    <div class="stop-content" id="stop-content">
      <!-- Dynamically filled -->
    </div>
  </div>

  <!-- ========== FINISH SCREEN ========== -->
  <div id="finish-screen" class="screen">
    <div class="finish-icon">&#127881;</div>
    <h1 class="finish-title" id="finish-title">Gefeliciteerd!</h1>
    <p class="finish-text" id="finish-text"></p>
    <button class="btn btn-primary" onclick="showStopList()">
      Bekijk de route &#10148;
    </button>
  </div>

  <!-- ========== SUCCESS OVERLAY ========== -->
  <div class="success-overlay" id="success-overlay">
    <div class="success-card">
      <div class="success-icon" id="success-icon">&#10003;</div>
      <div class="success-score" id="success-score"></div>
      <h3 class="success-title" id="success-title">Goed gedaan!</h3>
      <p class="success-text" id="success-text">Op naar de volgende stop...</p>
      <button class="btn btn-primary" id="success-btn" onclick="closeSuccessAndContinue()">
        Volgende stop &#10148;
      </button>
    </div>
  </div>

  <!-- Config (offline) -->
  <script src="config.js"></script>

  <!-- App Logic -->
  <script>
    // ============ STATE ============
    let currentStop = null;
    let completedStops = new Set();
    let answers = {};
    let scores = {};        // stopId -> { correct: N, total: N }
    let answersChecked = false; // prevents double-submit

    // ============ INIT ============
    function init() {
      loadState();
      const { name1, name2, years } = CONFIG.couple;
      document.getElementById('start-names').textContent = `${name1} & ${name2}`;
      document.getElementById('start-years').innerHTML = `<span>${years}</span> jaar getrouwd`;
      document.getElementById('total-count').textContent = CONFIG.stops.length;
      document.getElementById('finish-text').textContent =
        `${name1} & ${name2}, wat een prachtige tocht door ${years} jaar herinneringen!`;
      updateCompletedCount();
    }

    // ============ PERSISTENCE ============
    function loadState() {
      try {
        const saved = localStorage.getItem('trip-memory-lane-state');
        if (saved) {
          const state = JSON.parse(saved);
          completedStops = new Set(state.completed || []);
          answers = state.answers || {};
          scores = state.scores || {};
        }
      } catch (e) { /* ignore */ }
    }

    function saveState() {
      try {
        localStorage.setItem('trip-memory-lane-state', JSON.stringify({
          completed: Array.from(completedStops),
          answers: answers,
          scores: scores
        }));
      } catch (e) { /* ignore */ }
    }

    function updateCompletedCount() {
      document.getElementById('completed-count').textContent = completedStops.size;

      // Update total score in header
      const totalScoreEl = document.getElementById('total-score');
      if (totalScoreEl) {
        let totalCorrect = 0, totalTotal = 0;
        Object.values(scores).forEach(s => {
          totalCorrect += s.correct;
          totalTotal += s.total;
        });
        if (totalTotal > 0) {
          totalScoreEl.textContent = `Score: ${totalCorrect} / ${totalTotal} goed`;
        } else {
          totalScoreEl.textContent = '';
        }
      }
    }

    // ============ ANSWER CHECKING ============
    // Normalize text: lowercase, trim, remove punctuation
    function normalize(str) {
      return (str || '').toLowerCase().trim()
        .replace(/[.,!?;:'"()\-]/g, '')
        .replace(/\s+/g, ' ');
    }

    // Levenshtein distance for fuzzy matching
    function levenshtein(a, b) {
      const m = a.length, n = b.length;
      const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));
      for (let i = 0; i <= m; i++) dp[i][0] = i;
      for (let j = 0; j <= n; j++) dp[0][j] = j;
      for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
          dp[i][j] = Math.min(
            dp[i - 1][j] + 1,
            dp[i][j - 1] + 1,
            dp[i - 1][j - 1] + (a[i - 1] !== b[j - 1] ? 1 : 0)
          );
        }
      }
      return dp[m][n];
    }

    // Check if the given answer matches the correct answer
    // Allows small typos based on answer length
    function checkAnswer(given, correct) {
      const g = normalize(given);
      const c = normalize(correct);

      // Exact match after normalization
      if (g === c) return true;

      // Check if one contains the other (for partial answers)
      if (c.length > 3 && (g.includes(c) || c.includes(g))) return true;

      // Fuzzy match: allow typos proportional to length
      const maxDist = c.length <= 4 ? 0 : c.length <= 8 ? 1 : 2;
      if (levenshtein(g, c) <= maxDist) return true;

      return false;
    }

    // ============ NAVIGATION ============
    function showScreen(screenId) {
      document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
      document.getElementById(screenId).classList.add('active');
    }

    // ============ STOP LIST ============
    function showStopList() {
      renderStopList();
      showScreen('list-screen');
    }

    function getStopStatus(stop, index) {
      if (completedStops.has(stop.id)) return 'completed';
      const firstUncompletedIdx = CONFIG.stops.findIndex(s => !completedStops.has(s.id));
      if (index === firstUncompletedIdx) return 'current';
      return 'locked';
    }

    function renderStopList() {
      const container = document.getElementById('stop-list-area');
      updateCompletedCount();

      const totalStops = CONFIG.stops.length;
      let html = '';

      // Route items wrapper
      html += `<div class="route-items" id="route-items">`;

      // Start marker
      html += `<div class="route-marker start">`;
      html += `<div class="route-marker-icon">&#127937;</div>`;
      html += `<div class="route-marker-text">Start van de tocht</div>`;
      html += `</div>`;

      // Generate varied horizontal positions using seeded random
      // Each card gets a unique position, creating a winding route feel
      const posRng = (seed) => { let s = seed; return () => { s = (s * 16807 + 0) % 2147483647; return s / 2147483647; }; };
      const posRand = posRng(123); // fixed seed for consistent layout

      // Pre-define a set of horizontal "lanes" spread across the width
      // then shuffle them for organic feel while ensuring good spread
      const numStops = CONFIG.stops.length;
      const positions = [];
      let prevPos = 0.15; // start left-ish

      for (let i = 0; i < numStops; i++) {
        // Ensure minimum shift of 18% from previous position for clear separation
        let newPos;
        let attempts = 0;
        do {
          newPos = 0.02 + posRand() * 0.50; // range: 2% to 52%
          attempts++;
        } while (Math.abs(newPos - prevPos) < 0.18 && attempts < 20);

        positions.push(newPos);
        prevPos = newPos;
      }

      CONFIG.stops.forEach((stop, index) => {
        const status = getStopStatus(stop, index);
        const marginPct = (positions[index] * 100).toFixed(1);
        const isFinish = index === CONFIG.stops.length - 1;
        const finishClass = isFinish ? ' is-finish' : '';

        // Connector between stops
        html += `<div class="stop-list-connector"></div>`;

        const clickable = status === 'completed' ? ` onclick="showStop(${stop.id}, true)"` : '';
        html += `<div class="stop-list-item ${status}${finishClass}" style="margin-left:${marginPct}%"${clickable}>`;
        html += `<div class="stop-list-number">${isFinish ? '&#127937;' : stop.id}</div>`;
        html += `<div class="stop-list-info">`;
        html += `<div class="stop-list-title">${escapeHtml(stop.title)}</div>`;
        html += `<div class="stop-list-address">${escapeHtml(stop.address)}</div>`;
        if (isFinish) {
          html += `<div class="finish-badge"><span class="finish-badge-icon">&#127881;</span> De finish!</div>`;
        }
        html += `</div>`;
        html += `<div class="stop-list-action">`;
        if (status === 'completed') {
          const stopScore = scores[stop.id];
          const scoreText = stopScore ? `${stopScore.correct}/${stopScore.total}` : '';
          html += `<div class="stop-list-check">`;
          html += `<div class="stop-list-check-icon">&#10003;</div>`;
          if (scoreText) html += `<span class="stop-list-score">${scoreText}</span>`;
          html += `</div>`;
        } else if (status === 'current') {
          html += `<button class="btn-arrive" onclick="showStop(${stop.id})">We zijn er!</button>`;
        } else {
          html += `<div class="stop-list-lock">&#128274;</div>`;
        }
        html += `</div>`;
        html += `</div>`;
      });

      html += `</div>`; // close route-items

      container.innerHTML = html;

      // Draw the SVG winding path after layout is done
      requestAnimationFrame(() => {
        drawRoutePath(container);

        // Scroll to current stop
        const currentItem = container.querySelector('.stop-list-item.current');
        if (currentItem) {
          currentItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
      });
    }

    function drawRoutePath(container) {
      // Remove previous SVG if any
      const oldSvg = container.querySelector('.route-svg-bg');
      if (oldSvg) oldSvg.remove();

      const items = container.querySelectorAll('.stop-list-item');
      if (items.length === 0) return;

      const containerRect = container.getBoundingClientRect();
      const scrollTop = container.scrollTop;
      const svgW = container.scrollWidth;
      const svgH = container.scrollHeight;

      // Collect center points of each stop card
      const points = [];
      items.forEach(item => {
        const r = item.getBoundingClientRect();
        const cx = (r.left + r.width / 2) - containerRect.left;
        const cy = (r.top + r.height / 2) - containerRect.top + scrollTop;
        points.push({ x: cx, y: cy, el: item });
      });

      // Add start and end points
      const startMarker = container.querySelector('.route-marker.start');
      const finishMarker = container.querySelector('.route-marker.finish');
      let startPt = null, endPt = null;
      if (startMarker) {
        const r = startMarker.getBoundingClientRect();
        startPt = { x: (r.left + r.width / 2) - containerRect.left, y: (r.bottom) - containerRect.top + scrollTop };
      }
      if (finishMarker) {
        const r = finishMarker.getBoundingClientRect();
        endPt = { x: (r.left + r.width / 2) - containerRect.left, y: (r.top) - containerRect.top + scrollTop };
      }

      // Build smooth bezier path through all points
      const allPts = [];
      if (startPt) allPts.push(startPt);
      allPts.push(...points);
      if (endPt) allPts.push(endPt);

      let pathD = `M ${allPts[0].x} ${allPts[0].y}`;
      for (let i = 1; i < allPts.length; i++) {
        const prev = allPts[i - 1];
        const curr = allPts[i];
        const midY = (prev.y + curr.y) / 2;
        pathD += ` C ${prev.x} ${midY}, ${curr.x} ${midY}, ${curr.x} ${curr.y}`;
      }

      // Find how far completed progress goes
      let completedIdx = -1;
      items.forEach((item, i) => {
        if (item.classList.contains('completed')) completedIdx = i;
      });

      // Nature decorations (trees, bushes, flowers)
      const decos = [
        { e: '&#127794;', s: 28 },  // deciduous tree
        { e: '&#127795;', s: 24 },  // evergreen
        { e: '&#127793;', s: 18 },  // sunflower
        { e: '&#127800;', s: 16 },  // cherry blossom
        { e: '&#127807;', s: 20 },  // herb/bush
        { e: '&#127806;', s: 16 },  // wheat
        { e: '&#127799;', s: 15 },  // tulip
        { e: '&#129716;', s: 14 },  // potted plant
      ];
      // Larger scenery elements (less frequent)
      const bigDecos = [
        { e: '&#127794;', s: 36 },  // big tree
        { e: '&#127795;', s: 32 },  // big evergreen
      ];
      // Small ground details
      const smallDecos = [
        { e: '&#127807;', s: 12 },  // small herb
        { e: '&#127806;', s: 11 },  // small wheat
        { e: '&#127800;', s: 10 },  // small blossom
        { e: '&#127799;', s: 10 },  // small tulip
      ];

      let decoHtml = '';
      // Place nature decorations semi-randomly along the route
      const rng = (seed) => { let s = seed; return () => { s = (s * 16807 + 0) % 2147483647; return s / 2147483647; }; };
      const rand = rng(42);

      // Main decorations near each stop point
      for (let i = 0; i < allPts.length - 1; i++) {
        const p = allPts[i];
        // 3-5 medium decorations near each stop
        const numDecos = 3 + Math.floor(rand() * 3);
        for (let d = 0; d < numDecos; d++) {
          const deco = decos[Math.floor(rand() * decos.length)];
          const offsetX = (rand() > 0.5 ? 1 : -1) * (100 + rand() * 220);
          const offsetY = (rand() - 0.5) * 80;
          const x = Math.max(10, Math.min(svgW - 40, p.x + offsetX));
          const y = p.y + offsetY;
          const opacity = 0.3 + rand() * 0.25;
          const size = deco.s + Math.floor(rand() * 8);
          decoHtml += `<div class="nature-deco" style="left:${x}px;top:${y}px;font-size:${size}px;opacity:${opacity}">${deco.e}</div>`;
        }

        // 1-2 larger background trees per stop
        if (rand() > 0.3) {
          const big = bigDecos[Math.floor(rand() * bigDecos.length)];
          const bx = Math.max(20, Math.min(svgW - 50, p.x + (rand() > 0.5 ? 1 : -1) * (180 + rand() * 200)));
          const by = p.y + (rand() - 0.5) * 100;
          decoHtml += `<div class="nature-deco" style="left:${bx}px;top:${by}px;font-size:${big.s}px;opacity:${0.18 + rand() * 0.12}">${big.e}</div>`;
        }

        // 2-3 small ground details between stops
        const numSmall = 2 + Math.floor(rand() * 2);
        for (let s = 0; s < numSmall; s++) {
          const sm = smallDecos[Math.floor(rand() * smallDecos.length)];
          const sx = Math.max(5, Math.min(svgW - 20, p.x + (rand() - 0.5) * 350));
          const sy = p.y + 30 + rand() * 50;
          decoHtml += `<div class="nature-deco" style="left:${sx}px;top:${sy}px;font-size:${sm.s}px;opacity:${0.2 + rand() * 0.2}">${sm.e}</div>`;
        }
      }

      // Extra scattered decorations in empty areas along the edges
      const numEdgeDecos = Math.floor(svgH / 120);
      for (let i = 0; i < numEdgeDecos; i++) {
        const deco = decos[Math.floor(rand() * decos.length)];
        const side = rand() > 0.5;
        const x = side ? (svgW - 30 - rand() * 80) : (10 + rand() * 80);
        const y = 40 + rand() * (svgH - 80);
        const opacity = 0.15 + rand() * 0.2;
        const size = deco.s - 4 + Math.floor(rand() * 6);
        decoHtml += `<div class="nature-deco" style="left:${x}px;top:${y}px;font-size:${size}px;opacity:${opacity}">${deco.e}</div>`;
      }

      // Build SVG
      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('class', 'route-svg-bg');
      svg.setAttribute('width', svgW);
      svg.setAttribute('height', svgH);
      svg.style.width = svgW + 'px';
      svg.style.height = svgH + 'px';

      // Path shadow (road edge)
      const shadow = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      shadow.setAttribute('d', pathD);
      shadow.setAttribute('fill', 'none');
      shadow.setAttribute('stroke', 'rgba(139, 119, 90, 0.12)');
      shadow.setAttribute('stroke-width', '18');
      shadow.setAttribute('stroke-linecap', 'round');
      shadow.setAttribute('stroke-linejoin', 'round');
      svg.appendChild(shadow);

      // Main path (bike road)
      const road = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      road.setAttribute('d', pathD);
      road.setAttribute('fill', 'none');
      road.setAttribute('stroke', '#c4b48a');
      road.setAttribute('stroke-width', '10');
      road.setAttribute('stroke-linecap', 'round');
      road.setAttribute('stroke-linejoin', 'round');
      svg.appendChild(road);

      // Center dashes (road marking)
      const dashes = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      dashes.setAttribute('d', pathD);
      dashes.setAttribute('fill', 'none');
      dashes.setAttribute('stroke', 'rgba(255,255,255,0.5)');
      dashes.setAttribute('stroke-width', '2');
      dashes.setAttribute('stroke-dasharray', '8 12');
      dashes.setAttribute('stroke-linecap', 'round');
      svg.appendChild(dashes);

      // Completed portion overlay (green path)
      if (completedIdx >= 0) {
        const completedPts = [];
        if (startPt) completedPts.push(startPt);
        for (let i = 0; i <= completedIdx; i++) completedPts.push(points[i]);

        let cPathD = `M ${completedPts[0].x} ${completedPts[0].y}`;
        for (let i = 1; i < completedPts.length; i++) {
          const prev = completedPts[i - 1];
          const curr = completedPts[i];
          const midY = (prev.y + curr.y) / 2;
          cPathD += ` C ${prev.x} ${midY}, ${curr.x} ${midY}, ${curr.x} ${curr.y}`;
        }

        const greenRoad = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        greenRoad.setAttribute('d', cPathD);
        greenRoad.setAttribute('fill', 'none');
        greenRoad.setAttribute('stroke', '#6aaa6a');
        greenRoad.setAttribute('stroke-width', '10');
        greenRoad.setAttribute('stroke-linecap', 'round');
        greenRoad.setAttribute('stroke-linejoin', 'round');
        svg.appendChild(greenRoad);

        const greenDashes = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        greenDashes.setAttribute('d', cPathD);
        greenDashes.setAttribute('fill', 'none');
        greenDashes.setAttribute('stroke', 'rgba(255,255,255,0.6)');
        greenDashes.setAttribute('stroke-width', '2');
        greenDashes.setAttribute('stroke-dasharray', '8 12');
        greenDashes.setAttribute('stroke-linecap', 'round');
        svg.appendChild(greenDashes);
      }

      // Stop marker dots on the path
      points.forEach((pt, i) => {
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', pt.x);
        circle.setAttribute('cy', pt.y);
        const item = items[i];
        if (item.classList.contains('completed')) {
          circle.setAttribute('r', '7');
          circle.setAttribute('fill', '#5A8F5A');
          circle.setAttribute('stroke', '#fff');
          circle.setAttribute('stroke-width', '3');
        } else if (item.classList.contains('current')) {
          circle.setAttribute('r', '9');
          circle.setAttribute('fill', '#C9A84C');
          circle.setAttribute('stroke', '#fff');
          circle.setAttribute('stroke-width', '3');
        } else {
          circle.setAttribute('r', '5');
          circle.setAttribute('fill', '#bbb');
          circle.setAttribute('stroke', '#ddd');
          circle.setAttribute('stroke-width', '2');
        }
        svg.appendChild(circle);
      });

      container.appendChild(svg);

      // Add nature decorations
      const decoContainer = document.createElement('div');
      decoContainer.innerHTML = decoHtml;
      decoContainer.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:1;';
      container.appendChild(decoContainer);
    }

    // ============ STOP ============
    function showStop(stopId, reviewMode) {
      const stop = CONFIG.stops.find(s => s.id === stopId);
      if (!stop) return;

      currentStop = stop;
      answersChecked = reviewMode ? true : false;

      document.getElementById('stop-number').textContent = `Stop ${stop.id} van ${CONFIG.stops.length}`;
      document.getElementById('stop-title').textContent = stop.title;

      // Show/hide back button (always visible in review mode, hidden during active stop)
      const backBtn = document.getElementById('back-btn');
      backBtn.style.display = reviewMode ? 'flex' : 'none';

      const content = document.getElementById('stop-content');
      content.scrollTop = 0;

      let html = '';

      // Description
      html += `<p class="stop-description">${escapeHtml(stop.description)}</p>`;

      // Video
      html += `<div class="video-section">`;
      html += `<div class="section-label">Bekijk de video</div>`;
      html += `<div class="video-container">`;
      if (stop.video && stop.video.trim() !== '') {
        html += `<video controls playsinline>
                  <source src="${escapeHtml(stop.video)}" type="video/mp4">
                  Je browser ondersteunt geen video.
                </video>`;
      } else {
        html += `<div class="video-placeholder">
                  <div class="video-placeholder-icon">&#127916;</div>
                  <div>Video wordt later toegevoegd</div>
                </div>`;
      }
      html += `</div></div>`;

      // Questions
      if (stop.questions && stop.questions.length > 0) {
        html += `<div class="questions-section">`;

        if (reviewMode) {
          const stopScore = scores[stop.id];
          const scoreText = stopScore ? `${stopScore.correct} / ${stopScore.total} goed` : '';
          html += `<div class="section-label">Jullie antwoorden ${scoreText ? 'â€” ' + scoreText : ''}</div>`;
        } else {
          html += `<div class="section-label">Beantwoord de ${stop.questions.length === 1 ? 'vraag' : 'vragen'}</div>`;
        }

        stop.questions.forEach((q, idx) => {
          const answerKey = `${stop.id}-${idx}`;
          const savedAnswer = answers[answerKey] || '';

          if (reviewMode) {
            // Review mode: show answered questions with feedback
            const isCorrect = checkAnswer(savedAnswer, q.answer);
            const cardClass = isCorrect ? 'correct' : 'wrong';
            const inputClass = isCorrect ? 'correct' : 'wrong';

            html += `<div class="question-card ${cardClass}">
                      <div class="question-number">${stop.questions.length > 1 ? `Vraag ${idx + 1}` : 'De vraag'}</div>
                      <div class="question-text">${escapeHtml(q.text)}</div>
                      <textarea class="answer-input ${inputClass}" disabled rows="2">${escapeHtml(savedAnswer)}</textarea>
                      <div class="answer-feedback ${cardClass} show">`;

            if (isCorrect) {
              html += `<span class="answer-feedback-icon">&#10003;</span> Goed zo!`;
              if (q.hint && q.hint.trim()) {
                html += `<span class="hint-text">${escapeHtml(q.hint)}</span>`;
              }
            } else {
              html += `<span class="answer-feedback-icon">&#10007;</span> Helaas!`;
              html += `<span class="correct-answer">Het juiste antwoord: ${escapeHtml(q.answer)}</span>`;
              if (q.hint && q.hint.trim()) {
                html += `<span class="hint-text">${escapeHtml(q.hint)}</span>`;
              }
            }

            html += `</div></div>`;
          } else {
            // Active mode: editable inputs
            html += `<div class="question-card" id="qcard-${answerKey}">
                      <div class="question-number">${stop.questions.length > 1 ? `Vraag ${idx + 1}` : 'De vraag'}</div>
                      <div class="question-text">${escapeHtml(q.text)}</div>
                      <textarea class="answer-input" id="answer-${answerKey}"
                        placeholder="Typ jullie antwoord hier..." rows="2">${escapeHtml(savedAnswer)}</textarea>
                      <div class="answer-feedback" id="feedback-${answerKey}"></div>
                    </div>`;
          }
        });

        html += `</div>`;
      }

      // Bottom section
      if (reviewMode) {
        html += `<div class="submit-section">
                  <button class="btn btn-primary" onclick="showStopList()">
                    &#8592; Terug naar de route
                  </button>
                </div>`;
      } else {
        html += `<div class="submit-section">
                  <button class="btn btn-success" id="submit-btn" onclick="submitAnswers()">
                    Antwoord indienen &#10148;
                  </button>
                  <div class="submit-hint" id="submit-hint">Vul eerst alle vragen in</div>
                </div>`;
      }

      content.innerHTML = html;
      showScreen('stop-screen');
    }

    // ============ SUBMIT ============
    function submitAnswers() {
      if (!currentStop || answersChecked) return;

      let allFilled = true;
      const stop = currentStop;

      // First pass: check all fields are filled
      stop.questions.forEach((q, idx) => {
        const answerKey = `${stop.id}-${idx}`;
        const input = document.getElementById(`answer-${answerKey}`);
        const card = document.getElementById(`qcard-${answerKey}`);

        if (input && input.value.trim() === '') {
          allFilled = false;
          card.classList.add('error');
          input.classList.add('error');
          setTimeout(() => {
            card.classList.remove('error');
            input.classList.remove('error');
          }, 600);
        }
      });

      if (!allFilled) {
        const hint = document.getElementById('submit-hint');
        if (hint) {
          hint.classList.add('show');
          setTimeout(() => hint.classList.remove('show'), 3000);
        }
        const firstEmpty = stop.questions.findIndex((q, idx) => {
          const input = document.getElementById(`answer-${stop.id}-${idx}`);
          return input && input.value.trim() === '';
        });
        if (firstEmpty >= 0) {
          const card = document.getElementById(`qcard-${stop.id}-${firstEmpty}`);
          if (card) card.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
        return;
      }

      // All filled - now check answers
      answersChecked = true;
      let correctCount = 0;
      const totalQuestions = stop.questions.length;

      stop.questions.forEach((q, idx) => {
        const answerKey = `${stop.id}-${idx}`;
        const input = document.getElementById(`answer-${answerKey}`);
        const card = document.getElementById(`qcard-${answerKey}`);
        const feedback = document.getElementById(`feedback-${answerKey}`);

        if (!input || !card || !feedback) return;

        // Save the answer
        answers[answerKey] = input.value;

        // Disable input
        input.disabled = true;

        // Check correctness
        const isCorrect = checkAnswer(input.value, q.answer);
        if (isCorrect) correctCount++;

        // Show feedback
        card.classList.add(isCorrect ? 'correct' : 'wrong');
        input.classList.add(isCorrect ? 'correct' : 'wrong');

        let feedbackHtml = '';
        if (isCorrect) {
          feedbackHtml = `<span class="answer-feedback-icon">&#10003;</span> Goed zo!`;
          if (q.hint && q.hint.trim()) {
            feedbackHtml += `<span class="hint-text">${escapeHtml(q.hint)}</span>`;
          }
          feedback.className = 'answer-feedback correct show';
        } else {
          feedbackHtml = `<span class="answer-feedback-icon">&#10007;</span> Helaas!`;
          feedbackHtml += `<span class="correct-answer">Het juiste antwoord: ${escapeHtml(q.answer)}</span>`;
          if (q.hint && q.hint.trim()) {
            feedbackHtml += `<span class="hint-text">${escapeHtml(q.hint)}</span>`;
          }
          feedback.className = 'answer-feedback wrong show';
        }
        feedback.innerHTML = feedbackHtml;
      });

      // Save score
      scores[stop.id] = { correct: correctCount, total: totalQuestions };

      // Mark as completed
      completedStops.add(stop.id);
      saveState();

      // Change submit button to "Ga verder"
      const submitBtn = document.getElementById('submit-btn');
      submitBtn.innerHTML = 'Ga verder &#10148;';
      submitBtn.className = 'btn btn-primary';
      submitBtn.onclick = function() { showSuccessOverlay(stop, correctCount, totalQuestions); };

      // Scroll to first question to see feedback
      const firstCard = document.getElementById(`qcard-${stop.id}-0`);
      if (firstCard) firstCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }

    function showSuccessOverlay(stop, correctCount, totalQuestions) {
      const isLastStop = completedStops.size >= CONFIG.stops.length;
      const overlay = document.getElementById('success-overlay');
      const successIcon = document.getElementById('success-icon');
      const successScore = document.getElementById('success-score');
      const successTitle = document.getElementById('success-title');
      const successText = document.getElementById('success-text');
      const successBtn = document.getElementById('success-btn');

      // Show score
      successScore.textContent = `${correctCount} / ${totalQuestions}`;

      if (correctCount === totalQuestions) {
        successIcon.innerHTML = '&#127942;';
        successTitle.textContent = 'Perfect!';
      } else if (correctCount > 0) {
        successIcon.innerHTML = '&#128079;';
        successTitle.textContent = 'Goed gedaan!';
      } else {
        successIcon.innerHTML = '&#128170;';
        successTitle.textContent = 'Volgende keer beter!';
      }

      if (isLastStop) {
        // Calculate total score across all stops
        let totalCorrect = 0, totalTotal = 0;
        Object.values(scores).forEach(s => {
          totalCorrect += s.correct;
          totalTotal += s.total;
        });
        successText.textContent = `Totaalscore: ${totalCorrect} van ${totalTotal} vragen goed!`;
        successBtn.innerHTML = 'Bekijk het resultaat &#10148;';
      } else {
        const nextStop = CONFIG.stops.find(s => !completedStops.has(s.id));
        successText.textContent = nextStop
          ? `Op naar: ${nextStop.title}`
          : 'Op naar de volgende stop!';
        successBtn.innerHTML = 'Volgende stop &#10148;';
      }

      overlay.classList.add('show');

      // Launch confetti on the last stop or when all answers are correct
      if (isLastStop || correctCount === totalQuestions) {
        setTimeout(() => launchConfetti(), 300);
      }
    }

    function closeSuccessAndContinue() {
      const overlay = document.getElementById('success-overlay');
      overlay.classList.remove('show');

      const isLastStop = completedStops.size >= CONFIG.stops.length;

      setTimeout(() => {
        if (isLastStop) {
          showScreen('finish-screen');
          // Extra confetti burst on the finish screen!
          setTimeout(() => launchConfetti(), 400);
        } else {
          showStopList();
        }
      }, 300);
    }

    // ============ CONFETTI ============
    function launchConfetti() {
      const container = document.createElement('div');
      container.className = 'confetti-container';
      document.body.appendChild(container);

      const colors = ['#C9A84C', '#E8D5A3', '#5A8F5A', '#D9534F', '#5BC0DE', '#F0AD4E', '#FF69B4', '#9B59B6'];
      const shapes = ['square', 'circle', 'strip'];
      const count = 80;

      for (let i = 0; i < count; i++) {
        const piece = document.createElement('div');
        piece.className = 'confetti-piece';
        const color = colors[Math.floor(Math.random() * colors.length)];
        const shape = shapes[Math.floor(Math.random() * shapes.length)];
        const left = Math.random() * 100;
        const size = 6 + Math.random() * 10;
        const duration = 2 + Math.random() * 2;
        const delay = Math.random() * 0.8;

        const sway = -40 + Math.random() * 80; // horizontal sway in px

        piece.style.left = left + '%';
        piece.style.setProperty('--sway', sway + 'px');
        piece.style.backgroundColor = color;
        piece.style.width = shape === 'strip' ? (size * 0.4) + 'px' : size + 'px';
        piece.style.height = shape === 'strip' ? (size * 1.5) + 'px' : size + 'px';
        piece.style.borderRadius = shape === 'circle' ? '50%' : shape === 'strip' ? '2px' : '0';
        piece.style.animationDuration = duration + 's';
        piece.style.animationDelay = delay + 's';

        container.appendChild(piece);
      }

      // Clean up after animation completes
      setTimeout(() => container.remove(), 5000);
    }

    // ============ UTILS ============
    function escapeHtml(str) {
      if (!str) return '';
      const div = document.createElement('div');
      div.textContent = str;
      return div.innerHTML;
    }

    // ============ START ============
    init();
  </script>
</body>
</html>
